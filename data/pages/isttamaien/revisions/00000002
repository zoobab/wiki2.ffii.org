## -*- dok: IstTamai; lang: en; coding: iso-8859-1; mode: fundamental; -*-
= Software as Abstraction Physics  =
->
[ [[IstTamai98En| Tamai 98 on Abstraction]]
| [[SwpatcninoEn| Patent News]]
| [[FfiiprojNewsEn| Project News]]
]
----

The following is an initial entry and test by swpat hyphen 3seas at threeseas dot net.

== Physics of Abstraction (abstraction physics) ==

Abstraction enters the picture of computing with the representation of physical transistor switch positions of ON '1' and OFF '0' or what we call "Binary" notation.
However, computers have far more transistor switches in them than we can keep up with in such a low level or first order abstract manner, so we create higher level abstractions in order to increase our productivity in programming computers. From Machine language to application interfaces that allow users to define some sequence of action into a word or button press (ie. record and playback macro) so to automate a task, we are working with abstractions that ultimately accesses the hardware transistor switches which in turn output to, or control some physical world hardware.

Programming is the act of automating some level of complexity, usually made up of simpler complexities, but done so in order to allow the user to use and reuse the complexity through a simplified interface. And this is a recursive act, building upon abstractions others have created that even our own created abstractions/automations might be used by another to further create more complex automations. In general, if we didn't build upon what those before us have done, we then would not advance at all, but rather be like any other mammal incapable of anything more than, at best, first level abstraction. But we are more, and as such have the natural human right and duty to advance in such a manner.

There is an identifiable and definable "physics of abstraction" (abstraction physics), an identification of what is required in order to make and use abstractions. Abstraction Physics is not exclusive to computing but constantly in use by ... well... us humans. Elements or facets of abstraction physics include the actions of abstraction creation and use, such as defining a word to mean a more complex definition (word = definition, function-name = actions to take, etc.), Starting and Stopping (interfacing with) of an abstraction definition sequence, keeping track of where you are in the progress of abstraction sequence usage (moving from one abstraction to another), defining and changing "input from" direction, defining and changing "output to" direction, getting input to process (using variables or place holders to carry values), sequencially stepping thru abstraction/automation details (inherently includes optionally sending output), looking up the meaning of a word or symbol (abstraction) so to act upon or with it, identifing an abstraction or real item value so to act upon it, and putting constraints upon your abstraction lookups and identifications (when you look up a word in a dictionary you don't start at the beginning of the dictionary, but begin with the section that starts with the first letter then followed by the second, etc., and when you open a box with many items to stock, you identify each so as to know where to put it in stock.)    

Abstraction Physics has yet to be established/recognized in a broad "common acceptance" manner, similiar to the difficulty in the acceptance of the hindu-arabic decimal system (which included the concept that nothing can have value - re: the Zero place holder). It took three hundred years (from inception) for the innovation of the now common decimal system to overcome the far more limited Roman Numeral system. (NOTE: mathmatics and the symbol sets used are also abstractions and therefor a subset of abstraction possibilities and certainly an application of abstraction physics.) Though the act of programming is still younger than many who apply it, we are technologically moving at a much faster rate of incorporating innovations and better understandings of reality. There is a physics to abstraction creation and use which can be used to model and create a non-patentable user friendly general use, and dynamic, automation (abstraction creation and usage) tool, that also allows for organized placement and access of abstractions in a logical or mapable and navigateable manner (not unlike reference books we have today, from dictionaries, thesaurus, quick reference books to catalogs of parts, products, etc..) 

Nature likes three (3) in primaries, as color in light (additive - red, blue, green) and paint (subtractive - blue, yellow, red) from which we can create all other colors in the rainbow. This applies to abstraction physics as well, as there are three primary user interfaces. The command line, the Graphical User interface (GUI) and the side door port to application and functionality access (known by many different names and application levels such as API, IPC, dcom, dcop, D-bus, plumber, etc., but each having its limitation and typically not so end user friendly). And Like the primary colors, if you take one away or limit its use, you constrain the ability of the user in putting new automations together or modifying existing ones. Causing false limitations in user ability also applies to the abstraction actions mentioned above, constrain access and you constrain users ability to create or modify.

When abstraction physics becomes better accepted, it will be much more obvious (an anti-patent facet) that most software is of such qualities (natural law, physical phenomenon, abstract ideas, algorythims, etc.) to NOT qualify for patentability. Currently patent granting organizations have no solid reference point of "abstraction physics" from which to test software patent applications against, or re-evaluate granted software patents. 

The hindu-arabic decimal system enabled much more of the general population to apply mathmatics in a more powerful * manner than the roman numeral system allowed. Likewise, with the establishment and application of abstraction physics as common knowledge (as the decimal system is today, even taught in primary school) software will become genuinely free simply because it will be easy enough to create that the general population will be able to create it, or cause the machine to (recursive automation nature of programming), regardless of the resource limitations of the general population user regarding complexity details. Otherwise the act of programming becomes falsely constrained, as the acceptance of the decimal system, and its benefits, was constrained (perhaps by the roman numeral accountant elites protecting their vested interest.) 

(*) Worth noting: The Roman Numeral system and its mathmatical limitation would not have allowed us to develope such a level of math complexity required for us to create/invent much of what we have today, including computers. Yet at the introduction of the Hindu-Arabic Decimal system, such potential creations/inventions were not even imagined. Perhaps the same inability to see where the acceptance and open (free) application of "abstraction physics" will indeed lead us in time, is a natural human constraint that only helps to support false constraints of "software patents". With certainty, to see how abstraction physics would allow, or cause, a genuine new level of economic competition and products to emerge, where (like as hind-sight) the idea of software patents would be considered anti-economic, just as the idea of constraining the use of the hindu-arabic decimal system to only those who can afford to pay royalities or adhear to some political position, etc., would today be laughed at in many ways including economically. 
 
